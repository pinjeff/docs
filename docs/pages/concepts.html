<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link href="/docs/css/root.css" rel="stylesheet" />
    <title>
      Yoke
    </title>
  </head>
  <body>
    <label class="hamburger-menu">
      <input type="checkbox" />
    </label>
    <aside class="side-panel">
      <nav>
        <div>
          <a href="/docs/">
            home
          </a>
        </div>
        <hr />
        <div>
          <a href="/docs/pages/atc.html">
            Air Traffic Controller
          </a>
        </div>
        <hr />
        <div>
          <a href="/docs/pages/concepts.html">
            concepts
          </a>
        </div>
        <hr />
        <div>
          <a href="/docs/pages/cli.html">
            CLI reference
          </a>
        </div>
        <hr />
        <div>
          <a href="/docs/pages/examples.html">
            examples
          </a>
        </div>
        <hr />
        <div>
          <a href="/docs/pages/helm_compatibility.html">
            helm compatibility
          </a>
        </div>
        <hr />
        <div>
          <a href="/docs/pages/yokecd.html">
            yokeCD
          </a>
        </div>
      </nav>
    </aside>
    <div class="github-link">
      <img src="/docs/images/github-mark-white.svg" />
      <a href="https://github.com/yokecd/yoke">
        yoke
      </a>
    </div>
    <main>
      <h1>
        Concepts
      </h1>
      <section class="container">
        <h2 id="flights">
          Flights
        </h2>
        <h3>
          Overview
        </h3>
        <p>
          Flights in Yoke are analogous to Charts in Helm. A Chart is a collection of templates packaged as one referencable
          entity. Similarly, in Yoke, Flights refer to both the code that describes Kubernetes resources and the packaged
          WebAssembly (wasm) asset representing the executable.
        </p>
        <p>
          At its core, a Flight is a piece of software that generates Kubernetes resources. In that way, even a Helm Chart is
          a subset of Flights (Refer to
          <a href="/docs/pages/helm_compatibility.html">
            Helm Compatibility
          </a>
          for more
          information). This allows us to view Flights at two levels: High and Low Altitude Flights (High-Level vs Low-Level).
        </p>
        <h3>
          High-Altitude Flights
        </h3>
        <p>
          High-Level Flights are the programs / runtimes / compiled wasm executables that generate the Kubernetes Package
          Instance for deployment.
        </p>
        <h3>
          Low-Altitude Flights
        </h3>
        <p>
          Low-Level Flights are the building blocks of the software. These are most likely represented as functions that take
          inputs and return Kubernetes resources. They can be shared via their language's ecosystems: npm, go modules, cargo,
          gems, and so on.
        </p>
      </section>
      <section class="container">
        <h2 id="flight-outputs">
          Flight Output
        </h2>
        <p>
          Flights are programs that generate a list of arbitrary Kubernetes resources to be applied as a single release.
        </p>
        <p>
          The output can be structured in three different ways:
        </p>
        <ul>
          <li>
            A single resource.
          </li>
          <li>
            A list of resources.
          </li>
          <li>
            A list of lists of resources.
          </li>
        </ul>
        <p>
          The first format is useful when using Yoke to manage a single resource over time. It is functionally equivalent to a
          list containing a single resource but provides a more convenient representation.
        </p>
        <p>
          The second format, a list of resources, is the most common type of flight output. This represents the set of
          resources associated with your release.
        </p>
        <p>
          The third format, a list of lists of resources, still constitutes a single release, but the resources are applied in
          stages. This is useful for dependencies within a release. For example, if resource B depends on resource A being
          present in the cluster, we can deploy A in an earlier stage before B. Internally, a flat list of resources is
          treated as a list of lists where each inner list contains a single resource, representing a single deployment stage.
        </p>
        <p>
          Common use cases for staged releases include, but are not limited to:
        </p>
        <ul>
          <li>
            Deploying a Custom Resource Definition (CRD) before creating custom resources that depend on it.
          </li>
          <li>
            Creating namespaces before adding new resources to them.
          </li>
        </ul>
      </section>
      <section class="container">
        <h2 id="why-wasm">
          Why Wasm?
        </h2>
        <p>
          Yoke's goal is to enable software engineers to write packages for Kubernetes as code. The issue is that code is not
          easy to package, and code itself is useless without its runtime or compiler. Yoke would need to be able to get the
          appropriate runtime or compiler for any language, and moreover, it would need to get those dependencies compiled for
          the correct architecture and OS as where Yoke is running. This would be an enormous task.
        </p>
        <p>
          This leaves us with two options: either accept arbitrary input as packages or find a common target that many
          languages support. Yoke chooses both options.
        </p>
        <h3>
          Arbitrary Input
        </h3>
        <p>
          The former allows us to support any runtime, even those that do not compile to wasm. This allows us to write Flights
          in our beloved dynamic languages:
        </p>
        <pre><code class="language-bash"># Deploy a Flight defined in Python
python3 app.py | yoke takeoff my-release

# Or in Javascript
node app.js | yoke takeoff my-release

# Or in Ruby
ruby app.rb | yoke takeoff my-release

# Or directly from a file
yoke takeoff my-release < resources.yaml</code></pre>
        <p class="pre-list">
          However, it comes with serious drawbacks:
        </p>
        <ul>
          <li>
            There are no physical assets that we can version and checksum against.
          </li>
          <li>
            Arbitrary programs are running in a context that has access to your Kubernetes cluster.
          </li>
        </ul>
        <h3>
          Using Wasm
        </h3>
        <p class="pre-list">
          With wasm, we can solve all our problems, including the two mentioned above:
        </p>
        <ul>
          <li>
            We have a common target for multiple languages.
          </li>
          <li>
            A final asset that Yoke can track internally for changes.
          </li>
          <li>
            A runtime that is not dependent on OS/ARCH.
          </li>
          <li>
            A runtime that is sandboxed (cannot access the network or filesystem).
          </li>
        </ul>
        <p>
          Wasm being sandboxed is a big deal for us. It eliminates side-effects such as IO and makes our programs predictable.
          It buys us a measure of security too, given that should a supply chain attack happen in the dependencies of your
          programs, an attacker would
          <strong>
            not
          </strong>
          have direct access to your filesystem, the network, or ultimately
          your K8s cluster.
        </p>
        <p>
          Example:
        </p>
        <pre><code class="language-bash">GOOS=wasip1 GOARCH=wasm go build -o main.wasm ./my-flight
yoke takeoff my-release ./main.wasm</code></pre>
      </section>
      <section class="container">
        <h2 id="cluster-access">
          Cluster Access
        </h2>
        <p>
          Some Flight implementations may require generating random data, which is useful for tasks like creating initial
          passwords or generating cryptographic certificates. However, this approach has a drawback: the inability to
          reproduce the same values across runs. This can lead to unnecessary churn when deploying updated releases.
        </p>
        <p>
          One of the key advantages of using WebAssembly (Wasm) is its secure sandboxing, which ensures package
          implementations run in isolation without direct access to external systems. Since Wasm is merely an assembly
          instruction set, it can only perform numeric computations by itself.
        </p>
        <p>
          To extend Wasmâ€™s capabilities, we use the
          <strong>
            WebAssembly System Interface (WASI)
          </strong>
          , which allows
          external calls from the WebAssembly module to the host. Yoke leverages WASI to expose a single function:
          <strong>
            <em>
              k8s_lookup
            </em>
          </strong
    >
          .
        </p>
        <p>
          This function enables Flights to look up Kubernetes resources, but only those owned by the target release. This
          allows packages to reuse values from previous iterations, reducing unnecessary churn, rollouts, and downtime during
          updates.
        </p>
        <p>
          This feature is opt-in during takeoff:
        </p>
        <pre><code class="language-bash">yoke takeoff --cluster-access foo bar.wasm</code></pre>
        <h3>
          A Note on Security
        </h3>
        <p>
          Security-conscious users may wonder whether granting Flights access to the cluster introduces a vulnerability.
          However, Wasm modules do not have direct access to the cluster. Instead, they interact with the host Yoke program,
          which retrieves the requested resource and returns its JSON representation to the moduleâ€™s memory. The Wasm module
          itself
          <strong>
            cannot
          </strong>
          open sockets, file descriptors, or network connections.
        </p>
        <p>
          That said, this feature remains opt-in and is recommended for use only with trusted Flights.
        </p>
        <h3>
          Example Usage
        </h3>
        <p>
          The
          <strong>
            <em>
              k8s_lookup
            </em>
          </strong>
          function is a low-level host export, and users are not expected to call it
          directly. Instead, Yoke provides a Go package that wraps it in a more user-friendly API:
          <strong>
            github.com/yokecd/yoke/pkg/flight/wasi/k8s
          </strong>
          .
        </p>
        <p>
          For other languages, contributors are welcome to reference the implementation or request official support for their
          preferred ecosystem.
        </p>
        <p>
          A Go-based example can be found
          <a href="https://github.com/yokecd/examples/blob/main/flights/lookup/main.go">
            here
          </a>
          .
        </p>
        <pre><code id="lookup-example" class="language-go"></code></pre>
      </section>
      <script>
        for (const item of [
        {
        id: "lookup-example",
        url: "https://raw.githubusercontent.com/yokecd/examples/refs/heads/main/flights/lookup/main.go",
        },
        ]) {
        fetch(item.url)
        .then((resp) => resp.text())
        .then((value) => {
        document.getElementById(item.id).innerHTML = Prism.highlight(value, Prism.languages.go, "go");
        })
        .catch((err) => {
        console.error("failed to fetch content: " + err.toString());
        });
        }
      </script>
    </main>
    <footer></footer>
  </body>
  <link href="/docs/css/prism-vsc-dark.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
  <script type="module">
    Prism?.highlightAll();
  </script>
</html>